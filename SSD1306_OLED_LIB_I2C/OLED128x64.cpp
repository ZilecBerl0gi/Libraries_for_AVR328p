/*
 * OLED128x64.cpp
 *
 * Created: 06.04.2022 20:40:54
 *  Author: Mikhail
 */ 
#include "OLED128x64.h"

const uint8_t charMap[][5] PROGMEM = {
    {0x00, 0x00, 0x00, 0x00, 0x00}, //   0x20 32
    {0x00, 0x00, 0x6f, 0x00, 0x00}, // ! 0x21 33
    {0x00, 0x07, 0x00, 0x07, 0x00}, // " 0x22 34
    {0x14, 0x7f, 0x14, 0x7f, 0x14}, // # 0x23 35
    {0x8C, 0x92, 0xFF, 0x92, 0x62}, // $ 0x24 36
    {0x23, 0x13, 0x08, 0x64, 0x62}, // % 0x25 37
    {0x36, 0x49, 0x56, 0x20, 0x50}, // & 0x26 38
    {0x00, 0x00, 0x07, 0x00, 0x00}, // ' 0x27 39
    {0x00, 0x1c, 0x22, 0x41, 0x00}, // ( 0x28 40
    {0x00, 0x41, 0x22, 0x1c, 0x00}, // ) 0x29 41
    {0x14, 0x08, 0x3e, 0x08, 0x14}, // * 0x2a 42
    {0x08, 0x08, 0x3e, 0x08, 0x08}, // + 0x2b 43
    {0x00, 0x50, 0x30, 0x00, 0x00}, // , 0x2c 44
    {0x08, 0x08, 0x08, 0x08, 0x08}, // - 0x2d 45
    {0x00, 0x60, 0x60, 0x00, 0x00}, // . 0x2e 46
    {0x20, 0x10, 0x08, 0x04, 0x02}, // / 0x2f 47
    {0x3e, 0x51, 0x49, 0x45, 0x3e}, // 0 0x30 48
    {0x00, 0x42, 0x7f, 0x40, 0x00}, // 1 0x31 49
    {0x42, 0x61, 0x51, 0x49, 0x46}, // 2 0x32 50
    {0x21, 0x41, 0x45, 0x4b, 0x31}, // 3 0x33 51
    {0x18, 0x14, 0x12, 0x7f, 0x10}, // 4 0x34 52
    {0x27, 0x45, 0x45, 0x45, 0x39}, // 5 0x35 53
    {0x3c, 0x4a, 0x49, 0x49, 0x30}, // 6 0x36 54
    {0x01, 0x71, 0x09, 0x05, 0x03}, // 7 0x37 55
    {0x36, 0x49, 0x49, 0x49, 0x36}, // 8 0x38 56
    {0x06, 0x49, 0x49, 0x29, 0x1e}, // 9 0x39 57
    {0x00, 0x36, 0x36, 0x00, 0x00}, // : 0x3a 58
    {0x00, 0x56, 0x36, 0x00, 0x00}, // ; 0x3b 59
    {0x08, 0x14, 0x22, 0x41, 0x00}, // < 0x3c 60
    {0x14, 0x14, 0x14, 0x14, 0x14}, // = 0x3d 61
    {0x00, 0x41, 0x22, 0x14, 0x08}, // > 0x3e 62
    {0x02, 0x01, 0x51, 0x09, 0x06}, // ? 0x3f 63
    {0x3e, 0x41, 0x5d, 0x49, 0x4e}, // @ 0x40 64
    {0x7e, 0x09, 0x09, 0x09, 0x7e}, // A 0x41 65
    {0x7f, 0x49, 0x49, 0x49, 0x36}, // B 0x42 66
    {0x3e, 0x41, 0x41, 0x41, 0x22}, // C 0x43 67
    {0x7f, 0x41, 0x41, 0x41, 0x3e}, // D 0x44 68
    {0x7f, 0x49, 0x49, 0x49, 0x41}, // E 0x45 69
    {0x7f, 0x09, 0x09, 0x09, 0x01}, // F 0x46 70
    {0x3e, 0x41, 0x49, 0x49, 0x7a}, // G 0x47 71
    {0x7f, 0x08, 0x08, 0x08, 0x7f}, // H 0x48 72
    {0x00, 0x41, 0x7f, 0x41, 0x00}, // I 0x49 73
    {0x20, 0x40, 0x41, 0x3f, 0x01}, // J 0x4a 74
    {0x7f, 0x08, 0x14, 0x22, 0x41}, // K 0x4b 75
    {0x7f, 0x40, 0x40, 0x40, 0x40}, // L 0x4c 76
    {0x7f, 0x02, 0x0c, 0x02, 0x7f}, // M 0x4d 77
    {0x7f, 0x04, 0x08, 0x10, 0x7f}, // N 0x4e 78
    {0x3e, 0x41, 0x41, 0x41, 0x3e}, // O 0x4f 79
    {0x7f, 0x09, 0x09, 0x09, 0x06}, // P 0x50 80
    {0x3e, 0x41, 0x51, 0x21, 0x5e}, // Q 0x51 81
    {0x7f, 0x09, 0x19, 0x29, 0x46}, // R 0x52 82
    {0x46, 0x49, 0x49, 0x49, 0x31}, // S 0x53 83
    {0x01, 0x01, 0x7f, 0x01, 0x01}, // T 0x54 84
    {0x3f, 0x40, 0x40, 0x40, 0x3f}, // U 0x55 85
    {0x0f, 0x30, 0x40, 0x30, 0x0f}, // V 0x56 86
    {0x3f, 0x40, 0x30, 0x40, 0x3f}, // W 0x57 87
    {0x63, 0x14, 0x08, 0x14, 0x63}, // X 0x58 88
    {0x07, 0x08, 0x70, 0x08, 0x07}, // Y 0x59 89
    {0x61, 0x51, 0x49, 0x45, 0x43}, // Z 0x5a 90
    {0x00, 0x00, 0x7f, 0x41, 0x00}, // [ 0x5b 91
    {0x02, 0x04, 0x08, 0x10, 0x20}, // \ 0x5c 92
    {0x00, 0x41, 0x7f, 0x00, 0x00}, // ] 0x5d 93
    {0x04, 0x02, 0x01, 0x02, 0x04}, // ^ 0x5e 94
    {0x40, 0x40, 0x40, 0x40, 0x40}, // _ 0x5f 95
    {0x00, 0x00, 0x03, 0x04, 0x00}, // ` 0x60 96
    {0x20, 0x54, 0x54, 0x54, 0x78}, // a 0x61 97
    {0x7f, 0x48, 0x44, 0x44, 0x38}, // b 0x62 98
    {0x38, 0x44, 0x44, 0x44, 0x20}, // c 0x63 99
    {0x38, 0x44, 0x44, 0x48, 0x7f}, // d 0x64 100
    {0x38, 0x54, 0x54, 0x54, 0x18}, // e 0x65 101
    {0x08, 0x7e, 0x09, 0x01, 0x02}, // f 0x66 102
    {0x0c, 0x52, 0x52, 0x52, 0x3e}, // g 0x67 103
    {0x7f, 0x08, 0x04, 0x04, 0x78}, // h 0x68 104
    {0x00, 0x44, 0x7d, 0x40, 0x00}, // i 0x69 105
    {0x20, 0x40, 0x44, 0x3d, 0x00}, // j 0x6a 106
    {0x00, 0x7f, 0x10, 0x28, 0x44}, // k 0x6b 107
    {0x00, 0x41, 0x7f, 0x40, 0x00}, // l 0x6c 108
    {0x7c, 0x04, 0x18, 0x04, 0x78}, // m 0x6d 109
    {0x7c, 0x08, 0x04, 0x04, 0x78}, // n 0x6e 110
    {0x38, 0x44, 0x44, 0x44, 0x38}, // o 0x6f 111
    {0x7c, 0x14, 0x14, 0x14, 0x08}, // p 0x70 112
    {0x08, 0x14, 0x14, 0x18, 0x7c}, // q 0x71 113
    {0x7c, 0x08, 0x04, 0x04, 0x08}, // r 0x72 114
    {0x48, 0x54, 0x54, 0x54, 0x20}, // s 0x73 115
    {0x04, 0x3f, 0x44, 0x40, 0x20}, // t 0x74 116
    {0x3c, 0x40, 0x40, 0x20, 0x7c}, // u 0x75 117
    {0x1c, 0x20, 0x40, 0x20, 0x1c}, // v 0x76 118
    {0x3c, 0x40, 0x30, 0x40, 0x3c}, // w 0x77 119
    {0x44, 0x28, 0x10, 0x28, 0x44}, // x 0x78 120
    {0x0c, 0x50, 0x50, 0x50, 0x3c}, // y 0x79 121
    {0x44, 0x64, 0x54, 0x4c, 0x44}, // z 0x7a 122
    {0x00, 0x08, 0x36, 0x41, 0x41}, // { 0x7b 123
    {0x00, 0x00, 0x7f, 0x00, 0x00}, // | 0x7c 124
    {0x41, 0x41, 0x36, 0x08, 0x00}, // } 0x7d 125
    {0x04, 0x02, 0x04, 0x08, 0x04}, // ~ 0x7e 126
    
    {0x7E, 0x11, 0x11, 0x11, 0x7E},	//__А (0xC0).
    {0x7F, 0x49, 0x49, 0x49, 0x33},	//__Б (0xC1).
    {0x7F, 0x49, 0x49, 0x49, 0x36},	//__В (0xC2).
    {0x7F, 0x01, 0x01, 0x01, 0x03},	//__Г (0xC3).
    {0xE0, 0x51, 0x4F, 0x41, 0xFF},	//__Д (0xC4).
    {0x7F, 0x49, 0x49, 0x49, 0x41},	//__Е (0xC5).
    {0x77, 0x08, 0x7F, 0x08, 0x77},	//__Ж (0xC6).
    {0x41, 0x49, 0x49, 0x49, 0x36},	//__З (0xC7).
    {0x7F, 0x10, 0x08, 0x04, 0x7F},	//__И (0xC8).
    {0x7C, 0x21, 0x12, 0x09, 0x7C},	//__Й (0xC9).
    {0x7F, 0x08, 0x14, 0x22, 0x41},	//__К (0xCA).
    {0x20, 0x41, 0x3F, 0x01, 0x7F},	//__Л (0xCB).
    {0x7F, 0x02, 0x0C, 0x02, 0x7F},	//__М (0xCC).
    {0x7F, 0x08, 0x08, 0x08, 0x7F},	//__Н (0xCD).
    {0x3E, 0x41, 0x41, 0x41, 0x3E},	//__О (0xCE).
    {0x7F, 0x01, 0x01, 0x01, 0x7F},	//__П (0xCF).
    {0x7F, 0x09, 0x09, 0x09, 0x06},	//__Р (0xD0).
    {0x3E, 0x41, 0x41, 0x41, 0x22},	//__С (0xD1).
    {0x01, 0x01, 0x7F, 0x01, 0x01},	//__Т (0xD2).
    {0x47, 0x28, 0x10, 0x08, 0x07},	//__У (0xD3).
    {0x1C, 0x22, 0x7F, 0x22, 0x1C},	//__Ф (0xD4).
    {0x63, 0x14, 0x08, 0x14, 0x63},	//__Х (0xD5).
    {0x7F, 0x40, 0x40, 0x40, 0xFF},	//__Ц (0xD6).
    {0x07, 0x08, 0x08, 0x08, 0x7F},	//__Ч (0xD7).
    {0x7F, 0x40, 0x7F, 0x40, 0x7F},	//__Ш (0xD8).
    {0x7F, 0x40, 0x7F, 0x40, 0xFF},	//__Щ (0xD9).
    {0x01, 0x7F, 0x48, 0x48, 0x30},	//__Ъ (0xDA).
    {0x7F, 0x48, 0x30, 0x00, 0x7F},	//__Ы (0xDB).
    {0x00, 0x7F, 0x48, 0x48, 0x30},	//__Ь (0xDC).
    {0x22, 0x41, 0x49, 0x49, 0x3E},	//__Э (0xDD).
    {0x7F, 0x08, 0x3E, 0x41, 0x3E},	//__Ю (0xDE).
    {0x46, 0x29, 0x19, 0x09, 0x7F},	//__Я (0xDF).

    {0x20, 0x54, 0x54, 0x54, 0x78},	//__а (0xE0).
    {0x3C, 0x4A, 0x4A, 0x49, 0x31},	//__б (0xE1).
    {0x7C, 0x54, 0x54, 0x28, 0x00},	//__в (0xE2).
    {0x7C, 0x04, 0x04, 0x0C, 0x00},	//__г (0xE3).
    {0xE0, 0x54, 0x4C, 0x44, 0xFC},	//__д (0xE4).
    {0x38, 0x54, 0x54, 0x54, 0x18},	//__е (0xE5).
    {0x6C, 0x10, 0x7C, 0x10, 0x6C},	//__ж (0xE6).
    {0x44, 0x54, 0x54, 0x28, 0x00},	//__з (0xE7).
    {0x7C, 0x20, 0x10, 0x08, 0x7C},	//__и (0xE8).
    {0x78, 0x42, 0x24, 0x12, 0x78},	//__й (0xE9).
    {0x7C, 0x10, 0x28, 0x44, 0x00},	//__к (0xEA).
    {0x20, 0x44, 0x3C, 0x04, 0x7C},	//__л (0xEB).
    {0x7C, 0x08, 0x10, 0x08, 0x7C},	//__м (0xEC).
    {0x7C, 0x10, 0x10, 0x10, 0x7C},	//__н (0xED).
    {0x38, 0x44, 0x44, 0x44, 0x38},	//__о (0xEE).
    {0x7C, 0x04, 0x04, 0x04, 0x7C},	//__п (0xEF).
    {0x7C, 0x14, 0x14, 0x14, 0x08},	//__р (0xF0).
    {0x38, 0x44, 0x44, 0x44, 0x00},	//__с (0xF1).
    {0x04, 0x04, 0x7C, 0x04, 0x04},	//__т (0xF2).
    {0x0C, 0x50, 0x50, 0x50, 0x3C},	//__у (0xF3).
    {0x30, 0x48, 0xFE, 0x48, 0x30},	//__ф (0xF4).
    {0x44, 0x28, 0x10, 0x28, 0x44},	//__х (0xF5).
    {0x7C, 0x40, 0x40, 0x7C, 0xC0},	//__ц (0xF6).
    {0x0C, 0x10, 0x10, 0x10, 0x7C},	//__ч (0xF7).
    {0x7C, 0x40, 0x7C, 0x40, 0x7C},	//__ш (0xF8).
    {0x7C, 0x40, 0x7C, 0x40, 0xFC},	//__щ (0xF9).
    {0x04, 0x7C, 0x50, 0x50, 0x20},	//__ъ (0xFA).
    {0x7C, 0x50, 0x50, 0x20, 0x7C},	//__ы (0xFB).
    {0x7C, 0x50, 0x50, 0x20, 0x00},	//__ь (0xFC).
    {0x28, 0x44, 0x54, 0x54, 0x38},	//__э (0xFD).
    {0x7C, 0x10, 0x38, 0x44, 0x38},	//__ю (0xFE).
    {0x08, 0x54, 0x34, 0x14, 0x7C},	//__я (0xFF). 
    {0x38, 0x55, 0x54, 0x55, 0x18},	//__ё (0xFF). 
    
//     {0x7e, 0x09, 0x09, 0x09, 0x7e}, // А 192
//     {0x7F, 0x49, 0x49, 0x49, 0x71}, // Б
//     {0x7f, 0x49, 0x49, 0x49, 0x36}, // В
//     {0x7F, 0x01, 0x01, 0x01, 0x01}, // Г
//     {0x60, 0x3E, 0x21, 0x3F, 0x60}, // Д
//     {0x7f, 0x49, 0x49, 0x49, 0x41}, // Е
//     {0x76, 0x08, 0x7F, 0x08, 0x76}, // Ж
//     {0x21, 0x41, 0x45, 0x4b, 0x31}, // З
//     {0x7F, 0x20, 0x10, 0x08, 0x7F}, // И
//     {0x7E, 0x20, 0x11, 0x08, 0x7E}, // Й
//     {0x7f, 0x08, 0x14, 0x22, 0x41}, // К
//     {0x70, 0x0E, 0x01, 0x01, 0x7F}, // Л
//     {0x7f, 0x02, 0x0c, 0x02, 0x7f}, // М
//     {0x7f, 0x08, 0x08, 0x08, 0x7f}, // Н
//     {0x3e, 0x41, 0x41, 0x41, 0x3e}, // О
//     {0x7F, 0x01, 0x01, 0x01, 0x7F}, // П
//     {0x7f, 0x09, 0x09, 0x09, 0x06}, // Р
//     {0x3e, 0x41, 0x41, 0x41, 0x22}, // С
//     {0x01, 0x01, 0x7f, 0x01, 0x01}, // Т
//     {0x07, 0x48, 0x48, 0x48, 0x7F}, // У
//     {0x1C, 0x22, 0x7F, 0x22, 0x1C}, // Ф
//     {0x63, 0x14, 0x08, 0x14, 0x63}, // Х
//     {0x7F, 0x40, 0x40, 0x7F, 0xC0}, // Ц
//     {0x07, 0x08, 0x08, 0x08, 0x7F}, // Ч
//     {0x7F, 0x40, 0x7F, 0x40, 0x7F}, // Ш
//     {0x7F, 0x40, 0x7F, 0x40, 0xFF}, // Щ
//     {0x01, 0x7F, 0x48, 0x48, 0x70}, // Ъ
//     {0x7F, 0x48, 0x70, 0x00, 0x7F}, // Ы
//     {0x00, 0x7F, 0x48, 0x48, 0x70}, // Ь
//     {0x22, 0x41, 0x49, 0x49, 0x3E}, // Э
//     {0x7F, 0x08, 0x3E, 0x41, 0x3E}, // Ю
//     {0x46, 0x29, 0x19, 0x09, 0x7F}, // Я 223
// 
//     {0x20, 0x54, 0x54, 0x54, 0x78}, //a 224
//     {0x3c, 0x4a, 0x4a, 0x49, 0x31}, //б
//     {0x7c, 0x54, 0x54, 0x28, 0x00}, //в
//     {0x7c, 0x04, 0x04, 0x04, 0x0c}, //г
//     {0xe0, 0x54, 0x4c, 0x44, 0xfc}, //д
//     {0x38, 0x54, 0x54, 0x54, 0x18}, //e
//     {0x6c, 0x10, 0x7c, 0x10, 0x6c}, //ж
//     {0x44, 0x44, 0x54, 0x54, 0x28}, //з
//     {0x7c, 0x20, 0x10, 0x08, 0x7c}, //и
//     {0x7c, 0x41, 0x22, 0x11, 0x7c}, //й
//     {0x7c, 0x10, 0x28, 0x44, 0x00}, //к
//     {0x20, 0x44, 0x3c, 0x04, 0x7c}, //л
//     {0x7c, 0x08, 0x10, 0x08, 0x7c}, //м
//     {0x7c, 0x10, 0x10, 0x10, 0x7c}, //н
//     {0x38, 0x44, 0x44, 0x44, 0x38}, //o
//     {0x7c, 0x04, 0x04, 0x04, 0x7c}, //п
//     {0x7C, 0x14, 0x14, 0x14, 0x08}, //p
//     {0x38, 0x44, 0x44, 0x44, 0x20}, //c
//     {0x04, 0x04, 0x7c, 0x04, 0x04}, //т
//     {0x0C, 0x50, 0x50, 0x50, 0x3C}, //у
//     {0x30, 0x48, 0xfc, 0x48, 0x30}, //ф
//     {0x44, 0x28, 0x10, 0x28, 0x44}, //x
//     {0x7c, 0x40, 0x40, 0x40, 0xfc}, //ц
//     {0x0c, 0x10, 0x10, 0x10, 0x7c}, //ч
//     {0x7c, 0x40, 0x7c, 0x40, 0x7c}, //ш
//     {0x7c, 0x40, 0x7c, 0x40, 0xfc}, //щ
//     {0x04, 0x7c, 0x50, 0x50, 0x20}, //ъ
//     {0x7c, 0x50, 0x50, 0x20, 0x7c}, //ы
//     {0x7c, 0x50, 0x50, 0x20, 0x00}, //ь
//     {0x28, 0x44, 0x54, 0x54, 0x38}, //э
//     {0x7c, 0x10, 0x38, 0x44, 0x38}, //ю
//     {0x08, 0x54, 0x34, 0x14, 0x7c}, //я 255

};

void OLED::init(int freq, bool Speed)
{
	if(Speed == 1)
	{
		freq_ = freq;
		oled_.Init(freq);
		oled_.setBitRate(freq,1);
	}
	else
	{
		freq_ = freq;
		oled_.Init(freq);
		oled_.setBitRate(700,64);
	}
	OLED::sendCommand(SSD1306_DISPLAYOFF);
	OLED::sendCommand(SSD1306_SETDISPLAYCLOCKDIV);
	OLED::sendCommand(0x80);
	OLED::sendCommand(SSD1306_CHARGEPUMP);
	OLED::sendCommand(0x14);
    OLED::sendCommand(SSD1306_MEMORYMODE);
    OLED::sendCommand(0x00);
	OLED::sendCommand(SSD1306_SETMULTIPLEX);
	OLED::sendCommand(0x3F);
	OLED::sendCommand(SSD1306_SETDISPLAYOFFSET);
	OLED::sendCommand(0x00);
	OLED::sendCommand(SSD1306_SETSTARTLINE | 0x00);
	OLED::sendCommand(SSD1306_SEGREMAP | 0x1);
	OLED::sendCommand(SSD1306_COMSCANDEC);
	OLED::sendCommand(SSD1306_SETCOMPINS);
	OLED::sendCommand(0x12);
	OLED::sendCommand(SSD1306_SETCONTRAST);
	OLED::sendCommand(0x1F);
	OLED::sendCommand(SSD1306_SETPRECHARGE);
	OLED::sendCommand(0xF1);
	OLED::sendCommand(SSD1306_SETVCOMDETECT);
	OLED::sendCommand(0x40);
	OLED::sendCommand(SSD1306_NORMALDISPLAY);
	OLED::sendCommand(SSD1306_DISPLAYON);
}

void OLED::drawRectangle(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, bool fill)
{
	if(x1 > 127 || x1 < 0 || y1 > 63 || y1 < 0 || x2 > 127 || x2 < 0 || y2 > 63 || y2 < 0)return;
	OLED::fastLineH(y1,x1,x2,fill);
	OLED::fastLineH(y2,x1,x2,fill);
	OLED::fastLineV(x1,y2,y1,fill);
	OLED::fastLineV(x2,y2,y1,fill);
}

void OLED::drawRectangleFillIn(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, bool fill)
{
	if(x1 > 127 || x1 < 0 || y1 > 63 || y1 < 0 || x2 > 127 || x2 < 0 || y2 > 63 || y2 < 0)return;
	if(x1 < x2)for(int i = x1; i < x2; i++)OLED::fastLineV(i,y2,y1,fill);
    else if(x2 < x1)for(int i = x2; i < x1; i++)OLED::fastLineV(i,y2,y1,fill);
}                                                    

void OLED::drawQuadrilateral(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1,uint8_t x2, uint8_t y2, uint8_t x3, uint8_t y3, bool fill /* = 1 */)
{
	if(x0 > 127 || x0 < 0 || y0 > 63 || y0 < 0 || x1 > 127 || x1 < 0 || y1 > 63 || y1 < 0 || x2 > 127 || x2 < 0 || y2 > 63 || y2 < 0 || x3 > 127 || x3 < 0 || y3 > 63 || y3 < 0)return;
	OLED::drawLine(x0,y0,x1,y1,fill);
	OLED::drawLine(x0,y0,x2,y2,fill);
	OLED::drawLine(x1,y1,x3,y3,fill);
	OLED::drawLine(x2,y2,x3,y3,fill);
}

void OLED::drawQuadrilateralFillIn(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1,uint8_t x2, uint8_t y2, uint8_t x3, uint8_t y3, bool fill /* = 1 */)
{
	if(x0 > 127 || x0 < 0 || y0 > 63 || y0 < 0 || x1 > 127 || x1 < 0 || y1 > 63 || y1 < 0 || x2 > 127 || x2 < 0 || y2 > 63 || y2 < 0 || x3 > 127 || x3 < 0 || y3 > 63 || y3 < 0)return;
	if(y0 < y2)for(int i = y0;i < y2;i++)OLED::drawLine(x0,i,x1,i+(y1-y0));
	else if(y0 > y2)for(int i = y2;i < y0;i++)OLED::drawLine(x0,i,x1,i+(y1-y0));
}

void OLED::drawLine(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1, bool fill)
{
	if(x0 > 127 || x0 < 0 || y0 > 127 || y0 < 0 || x1 > 127 || x1 < 0 || y1 > 127 || y1 < 0)return;
	if (x0 == x1) fastLineV(x0, y0, y1, fill);
	else if (y0 == y1) fastLineH(y0, x0, x1, fill);
	else {
		int sx, sy, e2, err;
		int dx = abs(x1 - x0);
		int dy = abs(y1 - y0);
		sx = (x0 < x1) ? 1 : -1;
		sy = (y0 < y1) ? 1 : -1;
		err = dx - dy;
		for (;;) {
			drawPixel(x0, y0, fill);
			if (x0 == x1 && y0 == y1) return;
			e2 = err<<1;
			if (e2 > -dy) {
				err -= dy;
				x0 += sx;
			}
			if (e2 < dx) {
				err += dx;
				y0 += sy;
			}
		}
	}
}

void OLED::fastLineH(uint8_t y, uint8_t x0, uint8_t x1, bool fill)
{
	if(x0 > 127 || x0 < 0 || y > 63 || y < 0)return;
	uint8_t bebra = 0;
	if (x0 > x1){bebra = x1; x1 = x0; x0 = bebra;}
	if (y < 0 || y > SSD1306_HEIGHT) return;
	if (x0 == x1) {
		drawPixel(x0, y, fill);
		return;
	}
	x1++;
	if(x0 < 0)x0 = 0;
	else if(x0 > SSD1306_WIDTH) x0 = SSD1306_WIDTH;
	if(x1 < 0)x1 = 0;
	else if(x1 > SSD1306_WIDTH) x1 = SSD1306_WIDTH;
	for (uint8_t x = x0; x < x1; x++) drawPixel(x, y, fill);
}

void OLED::fastLineV(uint8_t x, uint8_t y0, uint8_t y1, bool fill)
{
	if(x > 127 || x < 0 || y0 > 63 || y0 < 0 || y1 > 63 || y1 < 0)return;
	uint8_t bebra = 0;
	if (y0 > y1) {bebra = y1; y1 = y0; y0 = bebra;}
	if (x < 0 || x > SSD1306_WIDTH) return;
	if (y0 == y1) {
		drawPixel(x, y0, fill);
		return;
	}
	y1++;
	for (uint8_t y = y0; y < y1; y++) drawPixel(x, y, fill);
}

void OLED::drawCircle(uint8_t x, uint8_t y, uint8_t radius, bool fill)
{
	if(x > 127 || x < 0 || y > 63 || y < 0 || radius < 0 || radius > 26)return;
	int f = 1 - radius;
        int ddF_x = 1;
        int ddF_y = -2 * radius;
        uint8_t x1 = 0;
        uint8_t y1 = radius;
        
        uint8_t fillLine = (fill == 0) ? 0 : 1;
        drawPixel(x, y + radius, fillLine);
        drawPixel(x, y - radius, fillLine);
        drawPixel(x + radius, y, fillLine);
        drawPixel(x - radius, y, fillLine);		
        //if (fill != OLED_STROKE) fastLineH(y, x - radius, x + radius-1, fillLine);
        if (fill != 1) fastLineV(x, y - radius, y + radius-1, fillLine);
        while (x1 < y1) {
            if(f >= 0) {
                y1--;
                ddF_y += 2;
                f += ddF_y;
            }
            x1++;
            ddF_x += 2;
            f += ddF_x;
            if (fill == 1) {			
                drawPixel(x + x1, y + y1);
                drawPixel(x - x1, y + y1);
                drawPixel(x + x1, y - y1);
                drawPixel(x - x1, y - y1);			
                drawPixel(x + y1, y + x1);
                drawPixel(x - y1, y + x1);
                drawPixel(x + y1, y - x1);
                drawPixel(x - y1, y - x1);
            } else {	// FILL / CLEAR
                
                fastLineV(x + x1, y - y1, y + y1, fillLine);
                fastLineV(x - x1, y - y1, y + y1, fillLine);
                fastLineV(x + y1, y - x1, y + x1, fillLine);
                fastLineV(x - y1, y - x1, y + x1, fillLine);	
                /*
                fastLineH(y + y1, x - x1, x + x1-1, fillLine);
                fastLineH(y - y1, x - x1, x + x1-1, fillLine);
                fastLineH(y + x1, x - y1, x + y1-1, fillLine);
                fastLineH(y - x1, x - y1, x + y1-1, fillLine);	
                */				
            }
        }
}

void OLED::drawCircleFillIn(uint8_t x, uint8_t y, uint8_t Radius, bool fill)
{
	if(x > 127 || x < 0 || y > 63 || y < 0 || Radius < 0 || Radius > 26)return;
	for(uint8_t radius = Radius; radius >= 0; radius--)
	{
		int f = 1 - radius;
        int ddF_x = 1;
        int ddF_y = -2 * radius;
        uint8_t x1 = 0;
        uint8_t y1 = radius;
        
        uint8_t fillLine = (fill == 0) ? 0 : 1;
        drawPixel(x, y + radius, fillLine);
        drawPixel(x, y - radius, fillLine);
        drawPixel(x + radius, y, fillLine);
        drawPixel(x - radius, y, fillLine);		
        //if (fill != OLED_STROKE) fastLineH(y, x - radius, x + radius-1, fillLine);
        if (fill != 1) fastLineV(x, y - radius, y + radius-1, fillLine);
        while (x1 < y1) {
            if(f >= 0) {
                y1--;
                ddF_y += 2;
                f += ddF_y;
            }
            x1++;
            ddF_x += 2;
            f += ddF_x;
            if (fill == 1) {			
                drawPixel(x + x1, y + y1);
                drawPixel(x - x1, y + y1);
                drawPixel(x + x1, y - y1);
                drawPixel(x - x1, y - y1);			
                drawPixel(x + y1, y + x1);
                drawPixel(x - y1, y + x1);
                drawPixel(x + y1, y - x1);
                drawPixel(x - y1, y - x1);
            } else {	// FILL / CLEAR
                
                fastLineV(x + x1, y - y1, y + y1, fillLine);
                fastLineV(x - x1, y - y1, y + y1, fillLine);
                fastLineV(x + y1, y - x1, y + x1, fillLine);
                fastLineV(x - y1, y - x1, y + x1, fillLine);	
                /*
                fastLineH(y + y1, x - x1, x + x1-1, fillLine);
                fastLineH(y - y1, x - x1, x + x1-1, fillLine);
                fastLineH(y + x1, x - y1, x + y1-1, fillLine);
                fastLineH(y - x1, x - y1, x + y1-1, fillLine);	
                */				
            }
        }
	}
}

void OLED::setContrast(uint8_t value)
{
	oled_.StartCondition();
	oled_.sendByte(SSD1306_DEFAULT_ADDRESS);
	oled_.sendByte(0x00);
	oled_.sendByte(SSD1306_SETCONTRAST);
	oled_.sendByte(value);
	oled_.StopCondition();
}

void OLED::clear()
{
	for (uint16_t buffer_location = 0; buffer_location < SSD1306_BUFFERSIZE; buffer_location++) {
		OLED::buffer[buffer_location] = 0x00;
	}
}

void OLED::home()
{
	_x = 0;
	_y = 0;
}

void OLED::setAutoPrtLN(bool state)
{
	AutoPrtLn = state;
}

void OLED::update()
{
	OLED::sendCommand(SSD1306_COLUMNADDR);
	OLED::sendCommand(0x00);
	OLED::sendCommand(0x7F);
	OLED::sendCommand(SSD1306_PAGEADDR);
	OLED::sendCommand(0x00);
	OLED::sendCommand(0x07);
	for (uint8_t packet = 0; packet < 64; packet++) {
		oled_.StartCondition();
		oled_.sendByte(SSD1306_DEFAULT_ADDRESS);
		oled_.sendByte(0x40);
		for (uint8_t packet_byte = 0; packet_byte < 16; ++packet_byte) {
			oled_.sendByte(buffer[packet*16+packet_byte]);
		}
		oled_.StopCondition();
	}
}

void OLED::sendCommand(uint8_t Command)
{
	oled_.putBuffer(0x00);
	oled_.putBuffer(Command);
	oled_.sendByteAdressStream(SSD1306_DEFAULT_ADDRESS);
	oled_.clearBuffer();
}

void OLED::invert(bool inv)
{
	 if (inv) {
		 OLED::sendCommand(SSD1306_INVERTDISPLAY);
		 } else {
		 OLED::sendCommand(SSD1306_NORMALDISPLAY);
	 }
}

void OLED::drawPixel(uint8_t pos_x, uint8_t pos_y, bool pixel_status)
{
	if(pos_x > 127 || pos_x < 0 || pos_y > 63 || pos_y < 0)return;
	if (pixel_status) {
		OLED::buffer[pos_x+(pos_y/8)*SSD1306_WIDTH] |= (1 << (pos_y&0b111));
		} else {
		OLED::buffer[pos_x+(pos_y/8)*SSD1306_WIDTH] &= ~(1 << (pos_y&0b111));
	}
}

uint8_t OLED::getFont(uint8_t font, uint8_t row) {
	if (row > 4) return 0;
	font = font - '0' + 16;   // перевод код символа из таблицы ASCII
	//return pgm_read_byte(&(charMap[font][row]));
	if (font <= 95) {
		return pgm_read_byte(&(charMap[font][row])); 		// для английских букв и символов
		} else if (font >= 96 && font <= 111) {					// и пизд*ц для русских
		return pgm_read_byte(&(charMap[font - 48][row]));
		} else if (font <= 159) {
		return pgm_read_byte(&(charMap[font+7][row]));
		} else {
		return pgm_read_byte(&(charMap[font - 65][row]));	
	    } }

void OLED::setCursor(uint8_t x, uint8_t y)
{
	_x = x; _y = y;
}

void OLED::print(const char str[])
{
	for(int a = 0; a < strlen(str); a++)
	{
 		if(_x > SSD1306_WIDTH-4 && AutoPrtLn){_x = 0; _y += 8;}
 		if(_y > SSD1306_HEIGHT && AutoPrtLn)return;
	uint8_t b = str[a];
	for(uint8_t i = 0; i < 5; i++)
	{
	OLED::buffer[_x+(_y/8)*SSD1306_WIDTH]=getFont(b,i)^OLED::inv;
	_x++;
	}
	_x++;
	
    }
}

void OLED::print(long long Number)
{
	    char numString[10];
		ltoa(Number,numString,10);
		if(strlen(numString)*6 + _x > SSD1306_WIDTH-4){_x = 0; _y += 8;}
		for(int a = 0; a < strlen(numString); a++)
		{
			if(_y > SSD1306_HEIGHT && AutoPrtLn)return;
			uint8_t b = numString[a];
			for(uint8_t i = 0; i < 5; i++)
			{
				OLED::buffer[_x+(_y/8)*SSD1306_WIDTH]=getFont(b,i)^OLED::inv;
				_x++;
			}
			_x++;
		}
}

void OLED::print(int Number)
{
	char numString[10];
	itoa(Number,numString,10);
	if(strlen(numString)*6 + _x > SSD1306_WIDTH-4){_x = 0; _y += 8;}
	for(int a = 0; a < strlen(numString); a++)
	{
		if(_y > SSD1306_HEIGHT && AutoPrtLn)return;
		uint8_t b = numString[a];
		for(uint8_t i = 0; i < 5; i++)
		{
			OLED::buffer[_x+(_y/8)*SSD1306_WIDTH]=getFont(b,i)^OLED::inv;
			_x++;
		}
		_x++;
	}
}

void OLED::print(double Number)
{
	int WholePart = Number;
	int FactionalPart = abs((Number*100)-WholePart*100);
	char WString[10];
	char FString[10];
	ltoa(WholePart, WString, 10);
	ltoa(FactionalPart, FString, 10);
	if(strlen(WString)*6 + strlen(FString)*6 + 2 + _x > SSD1306_WIDTH-4){_x = 0; _y += 8;}\
	for(int a = 0; a < strlen(WString); a++)
	{
		if(_y > SSD1306_HEIGHT && AutoPrtLn)return;
		uint8_t b = WString[a];
		for(uint8_t i = 0; i < 5; i++)
		{
			OLED::buffer[_x+(_y/8)*SSD1306_WIDTH]=getFont(b,i)^OLED::inv;
			_x++;
		}
		_x++;
	}
	print(".");
	for(int a = 0; a < strlen(FString); a++)
	{
		if(_y > SSD1306_HEIGHT && AutoPrtLn)return;
		uint8_t b = FString[a];
		for(uint8_t i = 0; i < 5; i++)
		{
			OLED::buffer[_x+(_y/8)*SSD1306_WIDTH]=getFont(b,i)^OLED::inv;
			_x++;
		}
		_x++;
	}
}

void OLED::print(double Number, int Precision)
{
	int multiplier = 1;
	while(Precision != 0)
	{
		multiplier *= 10;
		Precision--;
	}
	int WholePart = Number;
	int FactionalPart = abs((Number*multiplier)-WholePart*multiplier);
	char WString[10];
	char FString[10];
	ltoa(WholePart, WString, 10);
	ltoa(FactionalPart, FString, 10);
	if(strlen(WString)*6 + strlen(FString)*6 + 2 + _x > SSD1306_WIDTH-4){_x = 0; _y += 8;}
	for(int a = 0; a < strlen(WString); a++)
	{
		if(_y > SSD1306_HEIGHT && AutoPrtLn)return;
		uint8_t b = WString[a];
		for(uint8_t i = 0; i < 5; i++)
		{
			OLED::buffer[_x+(_y/8)*SSD1306_WIDTH]=getFont(b,i)^OLED::inv;
			_x++;
		}
		_x++;
	}
	print(".");
	for(int a = 0; a < strlen(FString); a++)
	{
		if(_y > SSD1306_HEIGHT && AutoPrtLn)return;
		uint8_t b = FString[a];
		for(uint8_t i = 0; i < 5; i++)
		{
			OLED::buffer[_x+(_y/8)*SSD1306_WIDTH]=getFont(b,i)^OLED::inv;
			_x++;
		}
		_x++;
	}
}

void OLED::drawBITMAP(const int *BITMAP, int Width, int Height, int x, int y, bool Invert)
{
	_x = x;
	_y = y;
    uint8_t inverter;
	if(Invert)inverter = 255;
	else inverter = 0;
	for(uint8_t h = 0; h < Height; h++)
	{
		for(uint8_t w = 0; w < Width; w++)
		{
			OLED::buffer[_x+(_y/8)*SSD1306_WIDTH]=pgm_read_word(&(BITMAP[h*Width+w]))^inverter;
			_x++;
		}
		_y+=8;
		_x=x;
	}
	
}

void OLED::invertText(bool state)
{
	if(state)OLED::inv=255;
	else OLED::inv=0;
}
